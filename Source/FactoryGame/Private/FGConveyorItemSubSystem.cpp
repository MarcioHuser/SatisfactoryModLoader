// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGConveyorItemSubSystem.h"

void FInstanceLODs::UpdateVisibility(int32 NumInstances){ }
void FInstanceLODs::AddBucketComponents(int32 Num, AActor* Outer){ }
void FInstanceLODs::AddInstance_Internal(AActor* Outer){ }
AFGConveyorItemSubsystem::AFGConveyorItemSubsystem() : Super() {
	this->mInitialPreAllocatedNumberOfItemTypes = 8;
	this->mInitialPreAllocatedNumberOfItemsInstances = 512;
	this->mItemInstanceIncrementSize = 32;
	this->mItemInstanceUpdateThreshold = 64;
	this->mItemTypeIncrementSize = 8;
	this->mMaxParallelTasks = 10;
	this->PrimaryActorTick.TickGroup = TG_PrePhysics; this->PrimaryActorTick.EndTickGroup = TG_PrePhysics; this->PrimaryActorTick.bTickEvenWhenPaused = false; this->PrimaryActorTick.bCanEverTick = true; this->PrimaryActorTick.bStartWithTickEnabled = true; this->PrimaryActorTick.bAllowTickOnDedicatedServer = false; this->PrimaryActorTick.TickInterval = 0.0166666675359011;
	this->bAlwaysRelevant = true;
}
AFGConveyorItemSubsystem* AFGConveyorItemSubsystem::Get(UWorld* world){ return nullptr; }
void AFGConveyorItemSubsystem::RegisterBelt(AFGBuildableConveyorBase* newBelt){ }
void AFGConveyorItemSubsystem::UnRegisterBelt(AFGBuildableConveyorBase* removedBelt){ }
void AFGConveyorItemSubsystem::Tick(float DeltaSeconds){ }
void AFGConveyorItemSubsystem::BeginPlay(){ }
bool AFGConveyorItemSubsystem::HandleDisabledState(){ return false; }
void AFGConveyorItemSubsystem::ResolvedRegistered(){ }
void AFGConveyorItemSubsystem::ResolveRemoved(){ }
void AFGConveyorItemSubsystem::ResolveNewTypes(){ }
void AFGConveyorItemSubsystem::ComputeViewCullAndDistance(const FVector PlayerLocation, FConveyorActorContainer<AFGBuildableConveyorBelt*>* Conveyors, FConveyorActorContainer<AFGBuildableConveyorLift*>* Lifts) { }
void AFGConveyorItemSubsystem::GatherTransformData(const TArray<bool> DistancesToUpdate, FConveyorActorContainer<AFGBuildableConveyorBelt*>* Belt, FConveyorActorContainer<AFGBuildableConveyorLift*>* Lifts) { }
void AFGConveyorItemSubsystem::UpdateGPUData(const TArray<bool> DistancesToUpdate) { }
void AFGConveyorItemSubsystem::UpdateBuckets() { }
void AFGConveyorItemSubsystem::Cleanup(TArray< bool > LodsToUpdate){ }
TArray< bool > AFGConveyorItemSubsystem::UpdateTimers(float DeltaTime){ return TArray<bool>(); }
bool AFGConveyorItemSubsystem::mIsConveyorRendererActive = false;